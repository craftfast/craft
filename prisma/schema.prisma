generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model WaitlistEntry {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("waitlist_entries")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  emailVerified DateTime?
  image         String?
  password      String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  accounts      Account[]
  projects      Project[]
  sessions      Session[]
  teamMembers   TeamMember[]
  ownedTeams    Team[]       @relation("TeamOwner")
  files         File[] // All files uploaded by this user

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Project {
  id               String           @id @default(cuid())
  name             String
  description      String?
  type             String           @default("document")
  status           String           @default("active")
  userId           String
  version          Int              @default(0) // v0 = template, v1+ = AI updates (for billing & history)
  generationStatus String           @default("template") // "template" | "generating" | "ready"
  lastCodeUpdateAt DateTime? // When code was last updated by AI
  aiModel          String? // Selected AI model for this project (e.g., "x-ai/grok-code-fast-1")
  codeFiles        Json             @default("{}") // Current project files as JSON { "path": "content" }
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  versions         ProjectVersion[]
  chatMessages     ChatMessage[]
  fileRecords      File[]           @relation("ProjectFiles") // File records for R2 storage (separate from files JSON)
  neonDatabase     NeonDatabase? // One Neon database per project

  @@map("projects")
}

// ============================================================================
// FILE STORAGE MODEL (R2/S3-backed, flexible & future-proof)
// ============================================================================

model File {
  id            String       @id @default(cuid())
  userId        String // Always required: Who uploaded/owns the file
  projectId     String? // Optional: Associated project (if any)
  chatMessageId String? // Optional: Chat message this file was uploaded with
  teamId        String? // Optional: Team this file belongs to (for team logos, etc.)
  path          String? // File path in project (e.g., "src/app/page.tsx") - null for non-code files
  r2Key         String       @unique // R2/S3 object key (e.g., "files/abc123/xyz789")
  r2Url         String // CDN URL for accessing the file
  fileName      String // Original filename
  mimeType      String? // MIME type (e.g., "image/png", "text/typescript")
  size          Int // File size in bytes
  purpose       String       @default("upload") // "source" | "image" | "asset" | "upload" | "profile" | "team-logo"
  version       Int          @default(1) // File version number
  isDeleted     Boolean      @default(false) // Soft delete flag
  metadata      Json? // Flexible metadata (dimensions, alt text, etc.)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  project       Project?     @relation("ProjectFiles", fields: [projectId], references: [id], onDelete: SetNull)
  chatMessage   ChatMessage? @relation(fields: [chatMessageId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([projectId])
  @@index([chatMessageId])
  @@index([teamId])
  @@index([r2Key])
  @@index([purpose])
  @@index([projectId, path]) // Fast lookup for project files by path
  @@index([chatMessageId, createdAt]) // Files for a chat message
  @@map("files")
}

model ChatMessage {
  id          String   @id @default(cuid())
  projectId   String
  role        String // "user" or "assistant"
  content     String   @db.Text
  fileChanges Json? // Array of file changes (path, type, language) for assistant messages
  createdAt   DateTime @default(now())
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  files       File[] // Files attached to this message

  @@index([projectId])
  @@index([projectId, createdAt]) // For querying messages by project and time
  @@map("chat_messages")
}

model ProjectVersion {
  id            String   @id @default(cuid())
  projectId     String
  version       Int // Version number (1, 2, 3, etc.)
  name          String? // Optional name/description for this version
  codeFiles     Json // Snapshot of all project files at this version
  chatMessageId String? // The chat message that triggered this version (if any)
  isBookmarked  Boolean  @default(false) // User can bookmark important versions
  isPublished   Boolean  @default(false) // Whether this version is published/live
  createdAt     DateTime @default(now())
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, version]) // Ensure version numbers are unique per project
  @@index([projectId, createdAt])
  @@index([projectId, isBookmarked])
  @@index([projectId, isPublished])
  @@map("project_versions")
}

// ============================================================================
// NEON DATABASE INTEGRATION
// ============================================================================

model NeonDatabase {
  id                String    @id @default(cuid())
  projectId         String    @unique // One database per project
  neonProjectId     String    @unique // Neon's project ID
  neonBranchId      String? // Main branch ID (for versioning)
  connectionUri     String // PostgreSQL connection string
  host              String // Database host
  database          String // Database name
  user              String // Database user/role
  password          String // Database password (encrypted in production)
  region            String    @default("aws-us-east-2") // AWS region
  pgVersion         Int       @default(17) // PostgreSQL version
  status            String    @default("active") // "provisioning", "active", "claimed", "suspended", "deleted"
  // Transfer/Claim Details
  transferRequestId String? // Transfer request ID (if claimable)
  claimUrl          String? // URL for user to claim ownership
  transferExpiresAt DateTime? // When transfer request expires
  claimedAt         DateTime? // When user claimed the database
  claimedByEmail    String? // Email of user who claimed it
  // Metadata
  isClaimable       Boolean   @default(true) // Whether user can claim ownership
  autoDeleteAt      DateTime? // Auto-delete unclaimed databases after X days
  metadata          Json? // Additional metadata (config, settings, etc.)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  project           Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([neonProjectId])
  @@index([status])
  @@index([transferExpiresAt])
  @@index([autoDeleteAt])
  @@map("neon_databases")
}

model Team {
  id           String            @id @default(cuid())
  name         String
  slug         String            @unique // URL-friendly identifier
  ownerId      String
  isPersonal   Boolean           @default(false) // True if this is the user's default personal team
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  owner        User              @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members      TeamMember[]
  subscription TeamSubscription?

  @@index([ownerId])
  @@index([isPersonal])
  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      String   @default("member") // "owner", "admin", "member"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId]) // User can only be a member once per team
  @@index([userId])
  @@index([teamId])
  @@map("team_members")
}

// ============================================================================
// SUBSCRIPTION & BILLING MODELS
// ============================================================================

model Plan {
  id                String             @id @default(cuid())
  name              String             @unique // "HOBBY", "PRO", "ENTERPRISE"
  displayName       String // "Hobby", "Pro", "Enterprise"
  description       String? // Plan description
  priceMonthlyUsd   Float // Monthly price in USD (0 for Hobby, 150 for Pro)
  features          Json // JSON array of plan features
  maxProjects       Int? // Max projects allowed (1000 soft limit = unlimited)
  databaseSizeGb    Float // Database storage in GB
  storageSizeGb     Float // File storage in GB
  monthlyTokenLimit Int? // Monthly AI token limit (1M for Hobby, 10M for Pro, null for Enterprise = unlimited)
  canPurchaseTokens Boolean            @default(false) // Can purchase additional tokens beyond limit
  isActive          Boolean            @default(true)
  sortOrder         Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  subscriptions     TeamSubscription[]

  @@index([name])
  @@index([isActive])
  @@map("plans")
}

model TeamSubscription {
  id                 String        @id @default(cuid())
  teamId             String
  planId             String
  status             String        @default("active") // "active", "cancelled", "expired", "past_due"
  currentPeriodStart DateTime      @default(now())
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean       @default(false)
  cancelledAt        DateTime?
  polarCheckoutId    String? // Last Polar checkout ID
  polarPaymentId     String? // Last Polar payment ID
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  team               Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  plan               Plan          @relation(fields: [planId], references: [id])
  usageRecords       UsageRecord[]
  invoices           Invoice[]

  @@unique([teamId]) // One active subscription per team
  @@index([teamId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@map("team_subscriptions")
}

// ============================================================================
// AI TOKEN USAGE TRACKING
// ============================================================================

model AITokenUsage {
  id           String   @id @default(cuid())
  teamId       String
  userId       String
  projectId    String
  model        String // "claude-sonnet-4.5", "gpt-5", "gemini-2.5-pro", etc.
  inputTokens  Int // Tokens in the prompt/input
  outputTokens Int // Tokens in the response/output
  totalTokens  Int // inputTokens + outputTokens
  costUsd      Float // Cost in USD for this usage
  endpoint     String? // "chat", "code-generation", "image-analysis", etc.
  createdAt    DateTime @default(now())

  @@index([teamId, createdAt])
  @@index([userId, createdAt])
  @@index([projectId, createdAt])
  @@index([model, createdAt])
  @@index([createdAt]) // For billing period queries
  @@map("ai_token_usage")
}

// ============================================================================
// INFRASTRUCTURE USAGE TRACKING
// ============================================================================

model UsageRecord {
  id                      String           @id @default(cuid())
  teamId                  String
  subscriptionId          String
  billingPeriodStart      DateTime
  billingPeriodEnd        DateTime
  // AI Usage
  aiTokensUsed            Int              @default(0)
  aiCostUsd               Float            @default(0)
  // Database Usage
  databaseSizeGb          Float            @default(0)
  databaseCostUsd         Float            @default(0)
  // Storage Usage
  storageSizeGb           Float            @default(0)
  storageCostUsd          Float            @default(0)
  // Bandwidth Usage
  bandwidthGb             Float            @default(0)
  bandwidthCostUsd        Float            @default(0)
  // Auth Usage (MAU - Monthly Active Users)
  authMau                 Int              @default(0)
  authCostUsd             Float            @default(0)
  // Edge Function Invocations
  edgeFunctionInvocations Int              @default(0)
  edgeFunctionCostUsd     Float            @default(0)
  // Total
  totalCostUsd            Float            @default(0)
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt
  subscription            TeamSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, billingPeriodStart]) // One record per billing period
  @@index([teamId, billingPeriodStart])
  @@index([billingPeriodEnd])
  @@map("usage_records")
}

// ============================================================================
// INVOICING & PAYMENT TRACKING
// ============================================================================

model Invoice {
  id                  String           @id @default(cuid())
  teamId              String
  subscriptionId      String
  invoiceNumber       String           @unique // e.g., "INV-2025-001"
  status              String           @default("draft") // "draft", "issued", "paid", "failed", "refunded"
  billingPeriodStart  DateTime
  billingPeriodEnd    DateTime
  // Line Items
  subscriptionFeeUsd  Float            @default(0) // Base plan fee
  aiUsageCostUsd      Float            @default(0)
  databaseCostUsd     Float            @default(0)
  storageCostUsd      Float            @default(0)
  bandwidthCostUsd    Float            @default(0)
  authCostUsd         Float            @default(0)
  edgeFunctionCostUsd Float            @default(0)
  // Totals
  subtotalUsd         Float            @default(0)
  taxUsd              Float            @default(0)
  totalUsd            Float            @default(0)
  currency            String           @default("USD") // "USD" or "EUR"
  // Payment Details
  polarCheckoutId     String?
  polarPaymentId      String?
  paidAt              DateTime?
  dueDate             DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  subscription        TeamSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([teamId])
  @@index([subscriptionId])
  @@index([status])
  @@index([billingPeriodStart])
  @@index([dueDate])
  @@map("invoices")
}

// ============================================================================
// PAYMENT TRANSACTIONS
// ============================================================================

model PaymentTransaction {
  id              String   @id @default(cuid())
  teamId          String
  invoiceId       String?
  amount          Float
  currency        String   @default("USD")
  status          String // "pending", "completed", "failed", "refunded"
  paymentMethod   String   @default("polar") // "polar", "stripe", etc.
  polarCheckoutId String?
  polarPaymentId  String?
  polarSignature  String?
  failureReason   String?
  metadata        Json? // Additional payment metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([teamId])
  @@index([invoiceId])
  @@index([status])
  @@index([polarCheckoutId])
  @@index([polarPaymentId])
  @@index([createdAt])
  @@map("payment_transactions")
}
