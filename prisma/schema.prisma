generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String            @id @default(cuid())
  name                    String?
  email                   String            @unique
  emailVerified           DateTime?
  image                   String?
  password                String?
  verificationToken       String?           @unique
  verificationTokenExpiry DateTime?
  preferredChatPosition   String            @default("right") // "left" or "right"
  preferredTheme          String            @default("dark") // "light" | "dark" | "system"
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  accounts                Account[]
  projects                Project[]
  sessions                Session[]
  files                   File[] // All files uploaded by this user
  subscription            UserSubscription?

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Project {
  id               String           @id @default(cuid())
  name             String
  description      String?
  type             String           @default("document")
  status           String           @default("active")
  visibility       String           @default("private") // "public" | "secret" | "private"
  userId           String
  version          Int              @default(0) // v0 = template, v1+ = AI updates (for billing & history)
  generationStatus String           @default("template") // "template" | "generating" | "ready"
  lastCodeUpdateAt DateTime? // When code was last updated by AI
  codeFiles        Json             @default("{}") // Current project files as JSON { "path": "content" }
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  versions         ProjectVersion[]
  chatMessages     ChatMessage[]
  fileRecords      File[]           @relation("ProjectFiles") // File records for R2 storage (separate from files JSON)

  @@map("projects")
}

// ============================================================================
// FILE STORAGE MODEL (R2/S3-backed, flexible & future-proof)
// ============================================================================

model File {
  id            String       @id @default(cuid())
  userId        String // Always required: Who uploaded/owns the file
  projectId     String? // Optional: Associated project (if any)
  chatMessageId String? // Optional: Chat message this file was uploaded with
  path          String? // File path in project (e.g., "src/app/page.tsx") - null for non-code files
  r2Key         String       @unique // R2/S3 object key (e.g., "files/abc123/xyz789")
  r2Url         String // CDN URL for accessing the file
  fileName      String // Original filename
  mimeType      String? // MIME type (e.g., "image/png", "text/typescript")
  size          Int // File size in bytes
  purpose       String       @default("upload") // "source" | "image" | "asset" | "upload" | "profile"
  version       Int          @default(1) // File version number
  isDeleted     Boolean      @default(false) // Soft delete flag
  metadata      Json? // Flexible metadata (dimensions, alt text, etc.)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  project       Project?     @relation("ProjectFiles", fields: [projectId], references: [id], onDelete: SetNull)
  chatMessage   ChatMessage? @relation(fields: [chatMessageId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([projectId])
  @@index([chatMessageId])
  @@index([r2Key])
  @@index([purpose])
  @@index([projectId, path]) // Fast lookup for project files by path
  @@index([chatMessageId, createdAt]) // Files for a chat message
  @@map("files")
}

model ChatMessage {
  id          String   @id @default(cuid())
  projectId   String
  role        String // "user" or "assistant"
  content     String   @db.Text
  fileChanges Json? // Array of file changes (path, type, language) for assistant messages
  createdAt   DateTime @default(now())
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  files       File[] // Files attached to this message

  @@index([projectId])
  @@index([projectId, createdAt]) // For querying messages by project and time
  @@map("chat_messages")
}

model ProjectVersion {
  id            String   @id @default(cuid())
  projectId     String
  version       Int // Version number (1, 2, 3, etc.)
  name          String? // Optional name/description for this version
  codeFiles     Json // Snapshot of all project files at this version
  chatMessageId String? // The chat message that triggered this version (if any)
  isBookmarked  Boolean  @default(false) // User can bookmark important versions
  isPublished   Boolean  @default(false) // Whether this version is published/live
  createdAt     DateTime @default(now())
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, version]) // Ensure version numbers are unique per project
  @@index([projectId, createdAt])
  @@index([projectId, isBookmarked])
  @@index([projectId, isPublished])
  @@map("project_versions")
}

// ============================================================================
// SUBSCRIPTION & BILLING MODELS
// ============================================================================

model Plan {
  id                String             @id @default(cuid())
  name              String             @unique // "HOBBY", "PRO", "ENTERPRISE"
  displayName       String // "Hobby", "Pro", "Enterprise"
  description       String? // Plan description
  priceMonthlyUsd   Float // Monthly price in USD (0 for Hobby, 50 for Pro, 0 for Enterprise = contact sales)
  features          Json // JSON array of plan features
  maxProjects       Int? // Max projects allowed (3 for Hobby, unlimited for Pro/Enterprise)
  monthlyTokenLimit Int? // Monthly AI token limit (100k for Hobby, 10M for Pro, null for Enterprise = custom)
  canPurchaseTokens Boolean            @default(false) // Can purchase additional tokens beyond limit (Pro & Enterprise only)
  isActive          Boolean            @default(true)
  sortOrder         Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  subscriptions     UserSubscription[]

  @@index([name])
  @@index([isActive])
  @@map("plans")
}

model UserSubscription {
  id                 String        @id @default(cuid())
  userId             String        @unique // One active subscription per user
  planId             String
  status             String        @default("active") // "active", "cancelled", "expired", "past_due"
  currentPeriodStart DateTime      @default(now())
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean       @default(false)
  cancelledAt        DateTime?
  polarCheckoutId    String? // Last Polar checkout ID
  polarPaymentId     String? // Last Polar payment ID
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  user               User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan               Plan          @relation(fields: [planId], references: [id])
  usageRecords       UsageRecord[]
  invoices           Invoice[]

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@map("user_subscriptions")
}

// ============================================================================
// AI TOKEN USAGE TRACKING
// ============================================================================

model AITokenUsage {
  id           String   @id @default(cuid())
  userId       String
  projectId    String
  model        String // "claude-sonnet-4.5", "gpt-5", "gemini-2.5-pro", etc.
  inputTokens  Int // Tokens in the prompt/input
  outputTokens Int // Tokens in the response/output
  totalTokens  Int // inputTokens + outputTokens
  costUsd      Float // Cost in USD for this usage
  endpoint     String? // "chat", "code-generation", "image-analysis", etc.
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
  @@index([projectId, createdAt])
  @@index([model, createdAt])
  @@index([createdAt]) // For billing period queries
  @@map("ai_token_usage")
}

// ============================================================================
// AI USAGE TRACKING
// ============================================================================

model UsageRecord {
  id                 String           @id @default(cuid())
  userId             String
  subscriptionId     String
  billingPeriodStart DateTime
  billingPeriodEnd   DateTime
  // AI Usage
  aiTokensUsed       Int              @default(0)
  aiCostUsd          Float            @default(0)
  // Total
  totalCostUsd       Float            @default(0)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  subscription       UserSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, billingPeriodStart]) // One record per billing period
  @@index([userId, billingPeriodStart])
  @@index([billingPeriodEnd])
  @@map("usage_records")
}

// ============================================================================
// INVOICING & PAYMENT TRACKING
// ============================================================================

model Invoice {
  id                 String           @id @default(cuid())
  userId             String
  subscriptionId     String
  invoiceNumber      String           @unique // e.g., "INV-2025-001"
  status             String           @default("draft") // "draft", "issued", "paid", "failed", "refunded"
  billingPeriodStart DateTime
  billingPeriodEnd   DateTime
  // Line Items
  subscriptionFeeUsd Float            @default(0) // Base plan fee
  aiUsageCostUsd     Float            @default(0)
  // Totals
  subtotalUsd        Float            @default(0)
  taxUsd             Float            @default(0)
  totalUsd           Float            @default(0)
  currency           String           @default("USD") // "USD" or "EUR"
  // Payment Details
  polarCheckoutId    String?
  polarPaymentId     String?
  paidAt             DateTime?
  dueDate            DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  subscription       UserSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionId])
  @@index([status])
  @@index([billingPeriodStart])
  @@index([dueDate])
  @@map("invoices")
}

// ============================================================================
// PAYMENT TRANSACTIONS
// ============================================================================

model PaymentTransaction {
  id              String   @id @default(cuid())
  userId          String
  invoiceId       String?
  amount          Float
  currency        String   @default("USD")
  status          String // "pending", "completed", "failed", "refunded"
  paymentMethod   String   @default("polar") // "polar", "stripe", etc.
  polarCheckoutId String?
  polarPaymentId  String?
  polarSignature  String?
  failureReason   String?
  metadata        Json? // Additional payment metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([invoiceId])
  @@index([status])
  @@index([polarCheckoutId])
  @@index([polarPaymentId])
  @@index([createdAt])
  @@map("payment_transactions")
}

// ============================================================================
// TOKEN PURCHASES
// ============================================================================

model TokenPurchase {
  id              String    @id @default(cuid())
  userId          String
  tokenAmount     Int // Number of tokens purchased (e.g., 1000000 for 1M tokens)
  priceUsd        Float // Price paid in USD (e.g., 5.00 for 1M tokens)
  currency        String    @default("USD")
  status          String    @default("pending") // "pending", "completed", "failed", "refunded", "expired"
  polarCheckoutId String?
  polarPaymentId  String?
  purchasedAt     DateTime  @default(now())
  expiresAt       DateTime? // Date when tokens expire (1 year from purchase)
  tokensRemaining Int // Tokens not yet used from this purchase
  transactionId   String? // Link to PaymentTransaction if needed
  metadata        Json? // Additional purchase metadata
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([polarCheckoutId])
  @@index([polarPaymentId])
  @@index([purchasedAt])
  @@index([expiresAt]) // Index for expiration queries
  @@map("token_purchases")
}

// ============================================================================
// DEPLOYMENT INTEGRATIONS (VERCEL, GITHUB, ETC.)
// ============================================================================

model VercelIntegration {
  id             String       @id @default(cuid())
  userId         String       @unique // One Vercel account per user
  accessToken    String // OAuth access token (encrypted in production)
  refreshToken   String? // OAuth refresh token
  tokenExpiresAt DateTime? // When the access token expires
  vercelUserId   String? // Vercel user ID
  vercelTeamId   String? // Vercel team ID (if applicable)
  email          String? // Vercel account email
  username       String? // Vercel username
  scopes         String[] // OAuth scopes granted
  isActive       Boolean      @default(true)
  lastSyncAt     DateTime? // Last time we synced with Vercel
  metadata       Json? // Additional Vercel metadata
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  deployments    Deployment[]

  @@index([userId])
  @@index([isActive])
  @@map("vercel_integrations")
}

model GitHubIntegration {
  id             String             @id @default(cuid())
  userId         String             @unique // One GitHub account per user
  accessToken    String // OAuth access token (encrypted in production)
  refreshToken   String? // OAuth refresh token (GitHub doesn't provide this currently)
  tokenExpiresAt DateTime? // When the access token expires (if applicable)
  githubUserId   Int // GitHub user ID
  login          String // GitHub username/login
  email          String? // GitHub account email
  name           String? // GitHub user's display name
  avatarUrl      String? // GitHub profile avatar
  scopes         String[] // OAuth scopes granted
  isActive       Boolean            @default(true)
  lastSyncAt     DateTime? // Last time we synced with GitHub
  metadata       Json? // Additional GitHub metadata
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  repositories   GitHubRepository[]

  @@index([userId])
  @@index([githubUserId])
  @@index([isActive])
  @@map("github_integrations")
}

model GitHubRepository {
  id                  String            @id @default(cuid())
  githubIntegrationId String
  projectId           String? // Associated Craft project (if any)
  githubRepoId        Int               @unique // GitHub repository ID
  name                String // Repository name
  fullName            String // Full name (owner/repo)
  owner               String // Repository owner
  isPrivate           Boolean           @default(true)
  defaultBranch       String            @default("main")
  htmlUrl             String // GitHub repository URL
  cloneUrl            String // Git clone URL
  sshUrl              String? // SSH clone URL
  description         String? // Repository description
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  githubIntegration   GitHubIntegration @relation(fields: [githubIntegrationId], references: [id], onDelete: Cascade)
  deployments         Deployment[]

  @@index([githubIntegrationId])
  @@index([projectId])
  @@index([githubRepoId])
  @@map("github_repositories")
}

model Deployment {
  id                  String             @id @default(cuid())
  projectId           String
  userId              String
  vercelIntegrationId String?
  githubRepositoryId  String?
  platform            String // "vercel", "netlify", "railway", "github-pages", "cloudflare", etc.
  status              String             @default("pending") // "pending", "building", "ready", "error", "cancelled"
  // Vercel-specific
  vercelDeploymentId  String? // Vercel deployment ID
  vercelProjectId     String? // Vercel project ID
  vercelUrl           String? // Deployment URL (e.g., "project.vercel.app")
  vercelAliases       String[] // Custom domains/aliases
  // GitHub-specific
  githubCommitSha     String? // Git commit SHA
  githubBranch        String? // Git branch name
  // Deployment metadata
  buildLog            String?            @db.Text // Build logs
  errorMessage        String? // Error message if failed
  startedAt           DateTime? // When deployment started
  completedAt         DateTime? // When deployment completed
  duration            Int? // Deployment duration in seconds
  metadata            Json? // Additional platform-specific metadata
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  vercelIntegration   VercelIntegration? @relation(fields: [vercelIntegrationId], references: [id], onDelete: SetNull)
  githubRepository    GitHubRepository?  @relation(fields: [githubRepositoryId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([userId])
  @@index([vercelIntegrationId])
  @@index([githubRepositoryId])
  @@index([platform])
  @@index([status])
  @@index([createdAt])
  @@map("deployments")
}

model Feedback {
  id        String   @id @default(cuid())
  userId    String?
  email     String?
  name      String?
  message   String   @db.Text
  sentiment String? // "positive", "neutral", "negative"
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("feedback")
}
